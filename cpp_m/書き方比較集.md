# cpp_m/書き方比較集.md

[重要] 本ドキュメントは、**業界・チーム・プロダクト特性**によって「よし」とされるC++の書き方が変わることを、学習用に整理したものです。  
[厳守] ここに書いた方針は「絶対」ではありません。**理由とトレードオフ**（安全性/速度/コード量/移植性/保守性）を理解して選ぶこと。  
[禁止] 「速度が速いらしい」など根拠の薄い理由で最適化を先行すること。理由: 読みにくさとバグを増やしやすい上、効果が出ないことが多いため。  
[推奨] まず **メンテ優先**で書き、必要な箇所だけ測定（プロファイル）して **速度優先**へ寄せる。理由: 工数と品質の両立がしやすいため。  

## 用語（C言語経験者向けの最短説明）
- **RAII**: 「リソースの取得/解放をオブジェクトの寿命に結びつける」考え方。  
  - Cの `malloc/free` や `fopen/fclose` を、C++では `std::unique_ptr` や `std::ifstream` の寿命で自動化するイメージ。
- **所有権**: 「誰が解放責任を持つか」。`unique_ptr` は所有者が1人、`shared_ptr` は共有。
- **参照/寿命**: `string_view` や `span` は「所有しない」ので、**元データの寿命が短いと危険**。
- **例外**: エラーを「戻り値」ではなく「例外」で上位へ伝搬する仕組み。  
  - 組み込み等では **例外禁止**のこともあり、その場合は戻り値/エラー構造体で表現する。

## 1. 優先事項別の書き方（例）

### 1.1 メンテ優先（読みやすさ・安全性を最大化）
- **特徴**
  - 名前で意図を表す（冗長でもOK）
  - 例外/戻り値で失敗を明示
  - `optional` / `expected` 的な型（環境に応じて）で「失敗しうる」を表す
  - 標準ライブラリ（アルゴリズム・コンテナ）を素直に使う
- **向きやすい業界/領域**
  - Webバックエンド、業務アプリ、ツール、研究開発、長期運用の製品全般

例（入力をintへ変換）:

```cpp
// メンテ優先: 失敗を optional で表す（失敗が型で分かる）
std::optional<int> parseInt(std::string_view text);

auto valueOpt = parseInt(token);
if (!valueOpt) {
  // どのトークンで失敗したかログに残す
}
```

### 1.2 コード量優先（短く書く・記述量を減らす）
- **特徴**
  - `auto` やラムダ、標準アルゴリズムで短縮
  - ただし「短い=読みやすい」ではない（短縮しすぎると逆に読めない）
- **向きやすい業界/領域**
  - 競技プログラミング、短命スクリプト、小規模ユーティリティ

例（統計計算を短く）:

```cpp
auto sum = std::accumulate(v.begin(), v.end(), 0LL);
auto [minIt, maxIt] = std::minmax_element(v.begin(), v.end());
```

### 1.3 速度優先（低遅延・高スループットを優先）
- **特徴**
  - 事前確保（`reserve`）、アロケーション削減
  - ループを素直に書く（標準アルゴリズムより最適化が効く場合も）
  - 文字列/入出力を最適化（`iostream`を避ける、バッファリングなど）
  - 分岐削減・データ局所性・SIMDなど（必要な場合のみ）
- **向きやすい業界/領域**
  - ゲーム、HFT/低遅延、画像/音声処理、組み込み（ただし組み込みは別制約も強い）

例（パースで無駄な確保を減らす）:

```cpp
// 速度寄り: 例外を使わず from_chars（環境によってはC++17/C++20の実装差あり）
// std::from_chars は例外を投げない。エラーコードで返す。
```

## 2. 業界・領域ごとの「よくある作法」

### 2.1 組み込み（Embedded）
- **よくある制約**
  - 例外禁止（`-fno-exceptions` 相当）、RTTI禁止、動的確保禁止/制限
  - C互換API、メモリ上限が厳しい、リアルタイム制約
- **よしとされやすい書き方**
  - 戻り値でエラーを表す（`bool`/`enum`/エラーコード）
  - リソースは静的確保、固定長バッファ
  - `std::string` を避ける/限定する（ヒープに依存）

例（例外を使わないエラー返し）:

```cpp
enum class errorCode { ok, invalidArgument };
struct parseResult { errorCode code; int value; };
parseResult parseIntNoException(std::string_view text);
```

### 2.2 ゲーム（Game）
- **特徴**
  - フレーム時間が重要（安定した性能）
  - アロケーション・GC的挙動を嫌う
- **よしとされやすい書き方**
  - `reserve` / プール / アロケータ設計
  - ログは非同期・軽量、例外は局所的に限定（方針は会社で差）

### 2.3 金融（特に低遅延/HFT）
- **特徴**
  - 1マイクロ秒単位の遅延やジッタが問題になることがある
- **よしとされやすい書き方**
  - 例外/動的確保/ロックを避ける（設計で排除）
  - 計測と検証を前提にした最適化

### 2.4 Webバックエンド/業務
- **特徴**
  - 変更頻度が高く、人が読む時間が支配的
- **よしとされやすい書き方**
  - 明確な命名、単体テスト、ログ、例外の整理
  - 「まず正しく、次に速く」

## 3. `cpp_m/` の読み方（このリポジトリ内での使い分け）
- **`cpp11.cpp`**: C++の基本思想（所有権・RAII・ラムダ）をC経験者向けに理解する
- **`cpp17.cpp`**: `optional` / `string_view`（寿命が重要）を重点理解
- **`cpp20.cpp`**: `span`（ポインタ+長さの安全版）と `concepts`（テンプレエラーを入口で分かりやすく）
- **`cpp23.cpp`**: 「最新機能はガードする」（機能テストマクロ）
- **`modern.cpp`**: まとめ（素直版と洗練版を比較し、結果一致でデグレ防止の考え方を学ぶ）

